# 碰到的出现场景
在arcface的loss中用到

# 先举例子
~~~python
>>> p
tensor([[3, 1, 4],
        [2, 4, 2],
        [3, 1, 1]])
>>> ppp = torch.where(p != 1)
>>> ppp
(tensor([0, 0, 1, 1, 1, 2]), tensor([0, 2, 0, 1, 2, 0]))
~~~

# 讲解
分为两部分
## 第一部分：为什么会输出tensor([0, 0, 1, 1, 1, 2])
## 第二部分：为什么会输出tensor([0, 2, 0, 1, 2, 0])
~~~python
### 第一部分解析：

在torch中，如果用where(单个参数)及where(p!=1)这么一个条件，    
会用    
tensor([[3, 1, 4],    
        [2, 4, 2],    
        [3, 1, 1]])    
中的每一个元素分别和 1 作比较，    
步骤一：首先知道一个知识点：对应位置产生对应数字    
                  第一行的元素和 1 做比较的时候，第一行有多少个元素就会生成多少个0    
                  第二行的元素和 1 作比较的时候，第二行有多少个元素就会生成多少个1    
                  第三行的元素和 1 作比较的时候，第三行有多少个元素就会生成多少个2    
                  ...    
                  依次类推    
例子中的                  
tensor([[3, 1, 4],    
        [2, 4, 2],    
        [3, 1, 1]])    
就会产生    
[0, 0, 0]    
[1, 1, 1]    
[2, 2, 2]    

步骤二：然后，当元素和 1 做比较的时候，如果符合条件 ！= 1，就会将对应位置上产生的对应数字留下，否则删掉对应位置上产生的对应数字    
例子中的    
tensor([[3, 1, 4],    
        [2, 4, 2],    
        [3, 1, 1]])    
就会产生    
[因符合故留下, 因不符合故删掉, 因符合故留下]    
[因符合故留下, 因符合故留下,   因符合故留下]    
[因符合故留下, 因不符合故删掉, 因不符合故删掉]    

步骤三：最后综合步骤一和步骤二的结果产生一个最终结果，并把最终结果顺序排列输出    
例子中的    
[0, 0, 0]    
[1, 1, 1]    
[2, 2, 2]    
和    
[因符合故留下, 因不符合故删掉, 因符合故留下]    
[因符合故留下, 因符合故留下,   因符合故留下]    
[因符合故留下, 因不符合故删掉, 因不符合故删掉]    
就会变成    
[0, null, 0]    
[1, 1,    1]    
[2, null, null]    
顺序排列输出以后得到(null不输出)    
0,0,1,1,1,2    

就和(tensor([0, 0, 1, 1, 1, 2])对应上了    

### 第二部分
和第一部分同样的方式，只不过把对应位置对应的数字 变成 对应位置的对应索引    

## 注意：
条件判断的时候要灵活运用，别被搞混了。        
另外小数也是一样的处理方式。    
~~~
